<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Confucian Café · React Demo</title>
  <style>
    :root {
      --chinese-red: #8B0000;
      --chinese-gold: #FFD700;
      --paper-beige: #F5F5DC;
      --light-cream: #FFFEF0;
      --ink-black: #1a1a1a;
      --level-1: #8B0000;
      --level-2: #B71C1C;
      --level-3: #555555;
      --level-4: #777777;
      --jade: #00A86B;
      --soft-white: rgba(255,255,255,0.95);
      --border: rgba(139,0,0,0.16);
      --shadow: 0 12px 40px rgba(26,26,26,0.12);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
      color: var(--ink-black);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', Roboto, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.45;
      padding: 0 0 60px 0;
    }

    h1 {
      font-size: 34px;
      font-weight: 900;
      letter-spacing: -0.6px;
      text-align: center;
      margin: 24px 0 18px 0;
      background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .app-grid {
      width: min(1180px, 96vw);
      margin: 0 auto;
      display: grid;
      grid-template-columns: 320px 1fr 260px;
      gap: 18px;
    }

    .panel {
      background: var(--soft-white);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      display: grid;
      gap: 14px;
      box-shadow: var(--shadow);
    }

    .inspector-column {
      display: grid;
      gap: 18px;
    }

    .prompt-meta {
      display: grid;
      gap: 6px;
      font-size: 12px;
      line-height: 1.3;
    }

    .prompt-meta strong {
      color: var(--level-2);
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .snapshot-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .code-block {
      font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
      background: rgba(0, 0, 0, 0.06);
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 6px;
      padding: 10px;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 220px;
      overflow-y: auto;
    }

    .agent-context-list {
      list-style: none;
      display: grid;
      gap: 8px;
      padding: 0;
      margin: 0;
    }

    .agent-context-list li {
      border: 1px solid rgba(139, 0, 0, 0.14);
      border-radius: 6px;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.96);
    }

    .agent-context-list li .meta {
      font-size: 11px;
      color: var(--level-4);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .inspector-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .panel header h3 {
      text-transform: uppercase;
      font-size: 15px;
      color: var(--level-2);
      letter-spacing: 0.6px;
    }

    .badge, .pill, .ghost-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      user-select: none;
    }

    .badge {
      background: rgba(139,0,0,0.08);
      border: 1px solid rgba(139,0,0,0.2);
      color: var(--level-2);
    }

    .pill {
      background: rgba(0,0,0,0.05);
      border: 1px solid rgba(0,0,0,0.08);
      color: var(--level-3);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pill.active {
      background: rgba(139,0,0,0.15);
      border-color: var(--chinese-red);
      color: var(--level-1);
    }

    .pill.highlight {
      background: rgba(0,168,107,0.16);
      border-color: var(--jade);
      color: var(--jade);
    }

    .ghost-button {
      border: 1px dashed rgba(139,0,0,0.28);
      background: rgba(139,0,0,0.04);
      color: var(--level-2);
      cursor: pointer;
    }

    .ghost-button.secondary {
      border-color: rgba(0,0,0,0.2);
      background: rgba(0,0,0,0.06);
      color: var(--level-3);
    }

    .toggle-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(255,255,255,0.96);
      padding: 12px;
      display: grid;
      gap: 6px;
    }

    .card header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--level-2);
      font-weight: 700;
    }

    .skill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .skill-list span {
      background: rgba(0,0,0,0.06);
      color: var(--level-3);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .dialogue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      border-radius: 8px;
      background: rgba(139,0,0,0.08);
    }

    .dialogue-header h3 {
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--level-2);
      letter-spacing: 0.5px;
    }

    .message-list {
      list-style: none;
      display: grid;
      gap: 12px;
      max-height: 360px;
      overflow-y: auto;
      padding-right: 6px;
    }

    .message {
      border: 1px solid rgba(139,0,0,0.1);
      border-radius: 8px;
      padding: 12px;
      background: white;
      display: grid;
      gap: 8px;
    }

    .message .meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--level-4);
    }

    .translation-block {
      background: rgba(139,0,0,0.05);
      border-left: 3px solid var(--chinese-red);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 12.5px;
      color: var(--level-3);
    }

    .insight {
      border: 1px dashed rgba(139,0,0,0.24);
      padding: 8px 10px;
      border-radius: 6px;
      background: rgba(255,215,0,0.12);
    }

    .insight summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--level-2);
    }

    .insight[open] summary { color: var(--level-1); }

    .timeline {
      display: grid;
      gap: 6px;
    }

    .timeline-step {
      border-left: 3px solid var(--chinese-red);
      padding: 8px 12px;
      border-radius: 6px;
      background: rgba(139,0,0,0.05);
      font-size: 13px;
    }

    .timeline-step.active {
      background: rgba(139,0,0,0.12);
      border-left-color: var(--chinese-gold);
    }

    .prompt-composer {
      border: 1px solid rgba(139,0,0,0.2);
      border-radius: 8px;
      padding: 12px;
      display: grid;
      gap: 10px;
      background: rgba(255,255,255,0.96);
    }

    .prompt-composer textarea {
      width: 100%;
      min-height: 70px;
      border-radius: 6px;
      border: 1px solid rgba(139,0,0,0.2);
      padding: 10px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }

    .prompt-composer .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
    }

    .primary-button {
      background: linear-gradient(135deg, rgba(139,0,0,0.85), rgba(205,92,92,0.9));
      color: white;
      border: none;
      padding: 8px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
    }

    .event-feed {
      font-family: 'SF Mono', 'Roboto Mono', Menlo, monospace;
      font-size: 12.5px;
      background: rgba(0,0,0,0.06);
      border-radius: 6px;
      padding: 10px;
      border: 1px solid rgba(0,0,0,0.1);
      display: grid;
      gap: 4px;
      max-height: 180px;
      overflow-y: auto;
    }

    footer {
      width: min(1180px, 96vw);
      margin: 26px auto 0;
      padding: 16px;
      text-align: center;
      background: rgba(139,0,0,0.08);
      border-radius: 8px;
      color: var(--level-2);
      font-weight: 600;
    }

    @media (max-width: 1080px) {
      .app-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <h1>Confucian Café · React Demo</h1>
  <div id="root"></div>

  <footer>Swap philosophers on the fly, keep English as the landing layer, and pull Chinese or insights only when you toggle.</footer>

  <script type="text/babel">
    const mockPhilosophers = [
      {
        id: 'confucius',
        name: 'Confucius',
        school: '儒家',
        port: 8001,
        showThoughts: true,
        personaSummary: 'Focus on ren 仁 and li 礼 to coordinate duty.',
        skills: ['share_position', 'critique', 'find_synthesis'],
      },
      {
        id: 'laozi',
        name: 'Laozi',
        school: '道家',
        port: 8002,
        showThoughts: false,
        personaSummary: 'Wu wei 无为; soften authority, guide like water.',
        skills: ['share_position', 'reframe'],
      },
      {
        id: 'mozi',
        name: 'Mozi',
        school: '墨家',
        port: 8003,
        showThoughts: true,
        personaSummary: 'Measure benefit; universal care over ritual.',
        skills: ['share_position', 'audit_policy'],
      },
      {
        id: 'mencius',
        name: 'Mencius',
        school: '儒家',
        port: 8004,
        showThoughts: false,
        personaSummary: 'Human nature is good; expand innate compassion.',
        skills: ['share_position', 'debate'],
      },
      {
        id: 'xunzi',
        name: 'Xunzi',
        school: '儒家',
        port: 8005,
        showThoughts: false,
        personaSummary: 'Human nature needs ritual discipline to become good.',
        skills: ['share_position', 'critique'],
      },
    ];

    const userPrompt = 'How should we coordinate Yellow River flood response so ritual alignment and logistics reinforce each other?';

    const promptTemplateSkeleton = `<Prompt>
  <SystemPersona philosopher="{philosopher}" version="2025-09-12">
    <![CDATA[
    {persona_core}
    ]]>
  </SystemPersona>

  <RoundDirective type="{round_type}" audience="{audience}">
    <Instruction>{round_instruction}</Instruction>
  </RoundDirective>

  <Context conversationId="{context_id}" round="{round}">
    <UserPrompt><![CDATA[{user_prompt}]]></UserPrompt>
    <PeerStatements>
      {peer_statements}
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`;

    const mockEvents = [
      {
        type: 'context-snapshot',
        id: 'ctx-1',
        phase: 'introduce',
        timestamp: '2025-10-06T08:59:50Z',
        contextId: 'dialogue-water-duty',
        round: 1,
        audience: 'confucius',
        userPrompt,
        prompt: {
          templateId: 'confucian_cafe.prompt.v1',
          templateSkeleton: promptTemplateSkeleton,
          rendered: `<Prompt>
  <SystemPersona philosopher="confucius" version="2025-09-12">
    <![CDATA[
    Embody ren (仁) and li (礼); ground responses in ritual order that stabilizes civic duty.
    ]]>
  </SystemPersona>

  <RoundDirective type="introduce" audience="all">
    <Instruction>Share your opening position on the flood governance scenario.</Instruction>
  </RoundDirective>

  <Context conversationId="dialogue-water-duty" round="1">
    <UserPrompt><![CDATA[${userPrompt}]]></UserPrompt>
    <PeerStatements>
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`
        },
        contextMessages: [],
      },
      {
        type: 'message',
        id: 'evt-1',
        phase: 'introduce',
        timestamp: '2025-10-06T09:00:00Z',
        speaker: 'confucius',
        surface: 'A stable river requires ritual order: align community duties so each hamlet knows its flood watch.',
        insight: 'Link li 礼 to practical duty; expect Mozi to push utility.',
      },
      {
        type: 'translation',
        id: 'evt-1-m',
        parentId: 'evt-1',
        language: 'modern',
        text: '河水要稳，需礼制齐备，让乡里各司其职守望。',
      },
      {
        type: 'translation',
        id: 'evt-1-c',
        parentId: 'evt-1',
        language: 'classical',
        text: '河患欲平，必礼序具备，使乡社各司水禁。',
      },
      {
        type: 'context-snapshot',
        id: 'ctx-2',
        phase: 'introduce',
        timestamp: '2025-10-06T09:01:30Z',
        contextId: 'dialogue-water-duty',
        round: 1,
        audience: 'laozi',
        userPrompt,
        prompt: {
          templateId: 'confucian_cafe.prompt.v1',
          templateSkeleton: promptTemplateSkeleton,
          rendered: `<Prompt>
  <SystemPersona philosopher="laozi" version="2025-09-12">
    <![CDATA[
    Guide with softness and wu wei; privilege adaptive governance over rigid command.
    ]]>
  </SystemPersona>

  <RoundDirective type="introduce" audience="all">
    <Instruction>Respond with a daoist framing that complements prior positions.</Instruction>
  </RoundDirective>

  <Context conversationId="dialogue-water-duty" round="1">
    <UserPrompt><![CDATA[${userPrompt}]]></UserPrompt>
    <PeerStatements>
      <Statement speaker="confucius" phase="introduce">
        <![CDATA[A stable river requires ritual order: align community duties so each hamlet knows its flood watch.]]>
      </Statement>
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`
        },
        contextMessages: [
          {
            id: 'evt-1',
            speaker: 'confucius',
            phase: 'introduce',
            surface: 'A stable river requires ritual order: align community duties so each hamlet knows its flood watch.',
            timestamp: '2025-10-06T09:00:00Z',
          },
        ],
      },
      {
        type: 'message',
        id: 'evt-2',
        phase: 'introduce',
        timestamp: '2025-10-06T09:02:00Z',
        speaker: 'laozi',
        surface: 'Let the water wander within soft banks; govern like tending bamboo—guide growth, do not hammer it straight.',
      },
      {
        type: 'context-snapshot',
        id: 'ctx-3',
        phase: 'introduce',
        timestamp: '2025-10-06T09:03:20Z',
        contextId: 'dialogue-water-duty',
        round: 1,
        audience: 'mozi',
        userPrompt,
        prompt: {
          templateId: 'confucian_cafe.prompt.v1',
          templateSkeleton: promptTemplateSkeleton,
          rendered: `<Prompt>
  <SystemPersona philosopher="mozi" version="2025-09-12">
    <![CDATA[
    Measure policy by benefit (利); favor universal care over ritual hierarchy.
    ]]>
  </SystemPersona>

  <RoundDirective type="introduce" audience="all">
    <Instruction>State your utilitarian approach to the shared flood scenario.</Instruction>
  </RoundDirective>

  <Context conversationId="dialogue-water-duty" round="1">
    <UserPrompt><![CDATA[${userPrompt}]]></UserPrompt>
    <PeerStatements>
      <Statement speaker="confucius" phase="introduce">
        <![CDATA[A stable river requires ritual order: align community duties so each hamlet knows its flood watch.]]>
      </Statement>
      <Statement speaker="laozi" phase="introduce">
        <![CDATA[Let the water wander within soft banks; govern like tending bamboo—guide growth, do not hammer it straight.]]>
      </Statement>
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`
        },
        contextMessages: [
          {
            id: 'evt-1',
            speaker: 'confucius',
            phase: 'introduce',
            surface: 'A stable river requires ritual order: align community duties so each hamlet knows its flood watch.',
            timestamp: '2025-10-06T09:00:00Z',
          },
          {
            id: 'evt-2',
            speaker: 'laozi',
            phase: 'introduce',
            surface: 'Let the water wander within soft banks; govern like tending bamboo—guide growth, do not hammer it straight.',
            timestamp: '2025-10-06T09:02:00Z',
          },
        ],
      },
      {
        type: 'message',
        id: 'evt-3',
        phase: 'introduce',
        timestamp: '2025-10-06T09:04:00Z',
        speaker: 'mozi',
        surface: 'Count the benefit: evacuate first, reinforce levees second, record lessons for every province.',
        insight: 'Prioritize measurable benefit; note ritual delays action.',
      },
      {
        type: 'phase-change',
        id: 'evt-4',
        phase: 'cross-response',
        timestamp: '2025-10-06T09:05:30Z',
      },
      {
        type: 'context-snapshot',
        id: 'ctx-4',
        phase: 'cross-response',
        timestamp: '2025-10-06T09:05:40Z',
        contextId: 'dialogue-water-duty',
        round: 2,
        audience: 'mozi',
        userPrompt,
        prompt: {
          templateId: 'confucian_cafe.prompt.v1',
          templateSkeleton: promptTemplateSkeleton,
          rendered: `<Prompt>
  <SystemPersona philosopher="mozi" version="2025-09-12">
    <![CDATA[
    Measure policy by benefit (利); favor universal care over ritual hierarchy.
    ]]>
  </SystemPersona>

  <RoundDirective type="cross-response" audience="mozi">
    <Instruction>Audit the prior arguments for measurable utility and outline immediate actions.</Instruction>
  </RoundDirective>

  <Context conversationId="dialogue-water-duty" round="2">
    <UserPrompt><![CDATA[${userPrompt}]]></UserPrompt>
    <PeerStatements>
      <Statement speaker="confucius" phase="introduce">
        <![CDATA[A stable river requires ritual order: align community duties so each hamlet knows its flood watch.]]>
      </Statement>
      <Statement speaker="laozi" phase="introduce">
        <![CDATA[Let the water wander within soft banks; govern like tending bamboo—guide growth, do not hammer it straight.]]>
      </Statement>
      <Statement speaker="mozi" phase="introduce">
        <![CDATA[Count the benefit: evacuate first, reinforce levees second, record lessons for every province.]]>
      </Statement>
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`
        },
        contextMessages: [
          {
            id: 'evt-1',
            speaker: 'confucius',
            phase: 'introduce',
            surface: 'A stable river requires ritual order: align community duties so each hamlet knows its flood watch.',
            timestamp: '2025-10-06T09:00:00Z',
          },
          {
            id: 'evt-2',
            speaker: 'laozi',
            phase: 'introduce',
            surface: 'Let the water wander within soft banks; govern like tending bamboo—guide growth, do not hammer it straight.',
            timestamp: '2025-10-06T09:02:00Z',
          },
          {
            id: 'evt-3',
            speaker: 'mozi',
            phase: 'introduce',
            surface: 'Count the benefit: evacuate first, reinforce levees second, record lessons for every province.',
            timestamp: '2025-10-06T09:04:00Z',
          },
        ],
      },
      {
        type: 'message',
        id: 'evt-5',
        phase: 'cross-response',
        timestamp: '2025-10-06T09:06:10Z',
        speaker: 'mozi',
        surface: 'Ritual can wait; measure the flow and deploy crews before ceremony.',
      },
      {
        type: 'translation',
        id: 'evt-5-m',
        parentId: 'evt-5',
        language: 'modern',
        text: '礼仪可以后置，先测水量，调度工匠，再谈仪式。',
      },
      {
        type: 'phase-change',
        id: 'evt-6',
        phase: 'synthesis',
        timestamp: '2025-10-06T09:08:00Z',
      },
      {
        type: 'context-snapshot',
        id: 'ctx-5',
        phase: 'synthesis',
        timestamp: '2025-10-06T09:08:10Z',
        contextId: 'dialogue-water-duty',
        round: 3,
        audience: 'confucius',
        userPrompt,
        prompt: {
          templateId: 'confucian_cafe.prompt.v1',
          templateSkeleton: promptTemplateSkeleton,
          rendered: `<Prompt>
  <SystemPersona philosopher="confucius" version="2025-09-12">
    <![CDATA[
    Embody ren (仁) and li (礼); ground responses in ritual order that stabilizes civic duty.
    ]]>
  </SystemPersona>

  <RoundDirective type="synthesis" audience="all">
    <Instruction>Compose a synthesis that encodes Mozi's schedule inside ritual checkpoints.</Instruction>
  </RoundDirective>

  <Context conversationId="dialogue-water-duty" round="3">
    <UserPrompt><![CDATA[${userPrompt}]]></UserPrompt>
    <PeerStatements>
      <Statement speaker="mozi" phase="cross-response">
        <![CDATA[Ritual can wait; measure the flow and deploy crews before ceremony.]]>
      </Statement>
      <Statement speaker="mozi" phase="introduce">
        <![CDATA[Count the benefit: evacuate first, reinforce levees second, record lessons for every province.]]>
      </Statement>
    </PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`
        },
        contextMessages: [
          {
            id: 'evt-5',
            speaker: 'mozi',
            phase: 'cross-response',
            surface: 'Ritual can wait; measure the flow and deploy crews before ceremony.',
            timestamp: '2025-10-06T09:06:10Z',
          },
          {
            id: 'evt-3',
            speaker: 'mozi',
            phase: 'introduce',
            surface: 'Count the benefit: evacuate first, reinforce levees second, record lessons for every province.',
            timestamp: '2025-10-06T09:04:00Z',
          },
        ],
      },
      {
        type: 'message',
        id: 'evt-7',
        phase: 'synthesis',
        timestamp: '2025-10-06T09:08:40Z',
        speaker: 'confucius',
        surface: 'Let us set rites that encode Mozi’s schedule: the ritual becomes the checklist for readiness.',
      },
    ];

    const initialLanguageDefaults = { english: true, modern: false, classical: false };

    function formatTime(ts) {
      return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function formatPhase(phase) {
      if (phase === 'introduce') return 'Phase 1';
      if (phase === 'cross-response') return 'Phase 2';
      if (phase === 'synthesis') return 'Phase 3';
      return '';
    }

    function instructionForPhase(phase) {
      if (phase === 'introduce') return 'Share your current stance and immediate recommendations.';
      if (phase === 'cross-response') return 'Critique or extend prior statements; be concrete about action.';
      if (phase === 'synthesis') return 'Synthesize the council and propose aligned next steps.';
      return 'Respond to the user prompt.';
    }

    function buildRenderedPrompt({ persona, phase, round, contextId, userPromptText, contextMessages, audience }) {
      const personaId = persona ? persona.id : 'council';
      const personaSummary = persona ? persona.personaSummary : 'Composite council broadcast reinforcing shared guidance.';
      const peerStatements = (contextMessages || [])
        .map(entry => `      <Statement speaker="${entry.speaker}" phase="${entry.phase}">\n        <![CDATA[${entry.surface}]]>\n      </Statement>`)
        .join('\n');

      const peerBlock = peerStatements.length > 0 ? `\n${peerStatements}\n    ` : '\n      <!-- No prior statements supplied -->\n    ';

      return `<Prompt>
  <SystemPersona philosopher="${personaId}" version="2025-09-12">
    <![CDATA[
    ${personaSummary}
    ]]>
  </SystemPersona>

  <RoundDirective type="${phase}" audience="${audience}">
    <Instruction>${instructionForPhase(phase)}</Instruction>
  </RoundDirective>

  <Context conversationId="${contextId}" round="${round}">
    <UserPrompt><![CDATA[${userPromptText}]]></UserPrompt>
    <PeerStatements>${peerBlock}</PeerStatements>
  </Context>

  <OutputContract schema="confucian_cafe.v1">
    <![CDATA[Return JSON with keys surface, insight, citations]]>
  </OutputContract>
</Prompt>`;
    }

    function enrichSnapshot(snapshot) {
      const contextMessages = snapshot.contextMessages || [];
      const callPayload = snapshot.callPayload || {
        conversationId: snapshot.contextId,
        audience: snapshot.audience,
        round: snapshot.round,
        prompt: snapshot.prompt?.rendered || '',
        metadata: {
          context: contextMessages.map(entry => ({
            id: entry.id,
            speaker: entry.speaker,
            phase: entry.phase,
            surface: entry.surface,
          })),
        },
      };

      return {
        ...snapshot,
        contextMessages,
        callPayload,
      };
    }

    function mergeEvent(prevMessages, event) {
      if (event.type === 'message') {
        const exists = prevMessages.some(m => m.id === event.id);
        if (exists) return prevMessages;
        return [...prevMessages, {
          ...event,
          translations: {},
        }];
      }
      if (event.type === 'translation') {
        return prevMessages.map(msg => {
          if (msg.id !== event.parentId) return msg;
          return {
            ...msg,
            translations: {
              ...msg.translations,
              [event.language]: event.text,
            },
          };
        });
      }
      return prevMessages;
    }

    function App() {
      const [activeIds, setActiveIds] = React.useState(['confucius', 'laozi', 'mozi']);
      const [languageDefaults, setLanguageDefaults] = React.useState(initialLanguageDefaults);
      const [showInsights, setShowInsights] = React.useState(true);
      const [messages, setMessages] = React.useState([]);
      const [currentPhase, setCurrentPhase] = React.useState('introduce');
      const [eventFeed, setEventFeed] = React.useState([]);
      const [contextSnapshots, setContextSnapshots] = React.useState([]);
      const [activeSnapshotId, setActiveSnapshotId] = React.useState(null);

      React.useEffect(() => {
        const timeouts = mockEvents.map((evt, index) => {
          return setTimeout(() => {
            if (evt.type === 'context-snapshot') {
              const enriched = enrichSnapshot(evt);
              setContextSnapshots(prev => {
                const existing = prev.filter(snapshot => snapshot.id !== enriched.id);
                const updated = [...existing, enriched].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                return updated;
              });
              setActiveSnapshotId(enriched.id);
              setEventFeed(prev => [...prev.slice(-7), `${formatTime(enriched.timestamp)} · context → ${enriched.audience}`]);
            } else if (evt.type === 'phase-change') {
              setCurrentPhase(evt.phase);
              setEventFeed(prev => [...prev.slice(-7), `${formatTime(evt.timestamp)} · phase → ${evt.phase}`]);
            } else if (evt.type === 'message') {
              setMessages(prev => mergeEvent(prev, evt));
              setEventFeed(prev => [...prev.slice(-7), `${formatTime(evt.timestamp)} · ${evt.speaker} → message`]);
            } else if (evt.type === 'translation') {
              setMessages(prev => mergeEvent(prev, evt));
              setEventFeed(prev => [...prev.slice(-7), `${formatTime(new Date().toISOString())} · translation (${evt.language})`]);
            }
          }, 900 * index);
        });
        return () => timeouts.forEach(clearTimeout);
      }, []);

      const roster = React.useMemo(
        () => mockPhilosophers.filter(p => activeIds.includes(p.id)),
        [activeIds]
      );

      const toggleActive = (id) => {
        setActiveIds(prev => prev.includes(id) ? prev.filter(x => x !== id) : [...prev, id]);
      };

      const requestTranslation = (messageId, language) => {
        setEventFeed(prev => [...prev.slice(-7), `${formatTime(new Date().toISOString())} · request → ${language}`]);
        // For the demo we instantly enable translation if it exists in mock data.
        const source = mockEvents.find(evt => evt.type === 'translation' && evt.parentId === messageId && evt.language === language);
        if (source) {
          setMessages(prev => mergeEvent(prev, source));
        }
      };

      const handlePrompt = ({ prompt, audience }) => {
        if (!prompt.trim()) return;
        const isoStamp = new Date().toISOString();
        const stamp = formatTime(isoStamp);
        const round = currentPhase === 'introduce' ? 1 : currentPhase === 'cross-response' ? 2 : 3;
        const persona = mockPhilosophers.find(p => p.id === audience);
        const contextForSnapshot = messages.map(message => ({
          id: message.id,
          speaker: message.speaker,
          phase: message.phase,
          surface: message.surface,
          timestamp: message.timestamp,
        }));

        const renderedPrompt = buildRenderedPrompt({
          persona,
          phase: currentPhase,
          round,
          contextId: 'dialogue-water-duty',
          userPromptText: prompt.trim(),
          contextMessages: contextForSnapshot,
          audience,
        });

        const liveSnapshot = enrichSnapshot({
          type: 'context-snapshot',
          id: `ctx-live-${Date.now()}`,
          phase: currentPhase,
          timestamp: isoStamp,
          contextId: 'dialogue-water-duty',
          round,
          audience,
          userPrompt: prompt.trim(),
          prompt: {
            templateId: 'confucian_cafe.prompt.v1',
            templateSkeleton: promptTemplateSkeleton,
            rendered: renderedPrompt,
          },
          contextMessages: contextForSnapshot,
          callPayload: {
            conversationId: 'dialogue-water-duty',
            audience,
            round,
            prompt: renderedPrompt,
            metadata: {
              context: contextForSnapshot.map(entry => ({
                id: entry.id,
                speaker: entry.speaker,
                phase: entry.phase,
                surface: entry.surface,
              })),
              includeInsights: showInsights,
            },
          },
        });

        setContextSnapshots(prev => {
          const updated = [...prev, liveSnapshot].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
          return updated;
        });
        setActiveSnapshotId(liveSnapshot.id);
        setEventFeed(prev => [...prev.slice(-7), `${stamp} · user → ${audience}`]);
        alert(`Mock prompt sent to ${audience}:\n\n${prompt}`);
      };

      return (
        <div className="app-grid">
          <PhilosopherRoster
            allPhilosophers={mockPhilosophers}
            activeIds={activeIds}
            onToggle={toggleActive}
          />

          <DialogueStream
            topic="Water Control Ethics"
            date="2025-10-06"
            messages={messages}
            roster={roster}
            languageDefaults={languageDefaults}
            showInsights={showInsights}
            currentPhase={currentPhase}
            onLanguageRequest={requestTranslation}
            onSendPrompt={handlePrompt}
          />

          <InspectorColumn
            contextSnapshots={contextSnapshots}
            activeSnapshotId={activeSnapshotId}
            onSelectSnapshot={setActiveSnapshotId}
            messages={messages}
            languageDefaults={languageDefaults}
            onLanguageDefaultsChange={setLanguageDefaults}
            showInsights={showInsights}
            onToggleInsights={setShowInsights}
            eventFeed={eventFeed}
          />
        </div>
      );
    }

    function PhilosopherRoster({ allPhilosophers, activeIds, onToggle }) {
      return (
        <aside className="panel">
          <header>
            <h3>Philosopher Lineup</h3>
            <span className="badge">Session · Autumn Seminar 2025</span>
          </header>
          <div className="toggle-bar">
            {allPhilosophers.map(philosopher => (
              <button
                key={philosopher.id}
                className={`pill ${activeIds.includes(philosopher.id) ? 'active' : ''}`}
                onClick={() => onToggle(philosopher.id)}
              >
                {philosopher.name}
              </button>
            ))}
          </div>
          {allPhilosophers
            .filter(p => activeIds.includes(p.id))
            .map(philosopher => (
              <div key={philosopher.id} className="card">
                <header>
                  <span>{philosopher.name}</span>
                  <span className="pill">{philosopher.school} · port {philosopher.port}</span>
                </header>
                <p>{philosopher.personaSummary}</p>
                <div className="skill-list">
                  {philosopher.skills.map(skill => (
                    <span key={skill}>{skill}</span>
                  ))}
                </div>
                {philosopher.showThoughts && <span className="pill highlight">Insights enabled</span>}
              </div>
            ))}
        </aside>
      );
    }

    function DialogueStream({
      topic,
      date,
      messages,
      roster,
      languageDefaults,
      showInsights,
      currentPhase,
      onLanguageRequest,
      onSendPrompt,
    }) {
      return (
        <section className="panel">
          <div className="dialogue-header">
            <div>
              <h3>Dialogue Stream</h3>
              <span className="pill active">Topic: {topic} · {date}</span>
            </div>
            <LanguageChips defaults={languageDefaults} />
          </div>

          <ol className="message-list">
            {messages.map(message => (
              <MessageCard
                key={message.id}
                message={message}
                philosopher={roster.find(p => p.id === message.speaker)}
                showInsights={showInsights && roster.some(p => p.id === message.speaker && p.showThoughts)}
                onLanguageRequest={onLanguageRequest}
              />
            ))}
            {messages.length === 0 && (
              <li className="message">
                <div className="meta">
                  <span>Waiting for events…</span>
                </div>
                <p>Mock SSE will stream sample dialogue in a moment.</p>
              </li>
            )}
          </ol>

          <Timeline currentPhase={currentPhase} />

          <PromptComposer onSubmit={onSendPrompt} roster={roster} />
        </section>
      );
    }

    function LanguageChips({ defaults }) {
      return (
        <div className="toggle-bar">
          <span className={`pill ${defaults.english ? 'active' : ''}`}>EN locked</span>
          <span className={`pill ${defaults.modern ? 'active' : ''}`}>现 · Modern auto</span>
          <span className={`pill ${defaults.classical ? 'active' : ''}`}>古 · Classical auto</span>
        </div>
      );
    }

    function MessageCard({ message, philosopher, showInsights, onLanguageRequest }) {
      const [expanded, setExpanded] = React.useState({});

      const toggleLanguage = (lang) => {
        onLanguageRequest(message.id, lang);
        setExpanded(prev => ({ ...prev, [lang]: !prev[lang] }));
      };

      return (
        <li className="message">
          <div className="meta">
            <span>
              {(philosopher?.name || message.speaker)} · {formatPhase(message.phase)} · {formatTime(message.timestamp)}
            </span>
            <span className="pill">EN surface</span>
          </div>
          <p>{message.surface}</p>
          <div className="toggle-bar">
            <button className="ghost-button" onClick={() => toggleLanguage('modern')}>
              {expanded.modern ? 'Hide Modern' : 'Show Modern Chinese'}
            </button>
            <button className="ghost-button secondary" onClick={() => toggleLanguage('classical')}>
              {expanded.classical ? 'Hide Classical' : 'Show Classical'}
            </button>
          </div>
          {expanded.modern && message.translations.modern && (
            <TranslationBlock label="现 · Modern Chinese" text={message.translations.modern} />
          )}
          {expanded.classical && message.translations.classical && (
            <TranslationBlock label="古 · Classical Chinese" text={message.translations.classical} />
          )}
          {showInsights && message.insight && (
            <details className="insight" open>
              <summary>Internal thoughts</summary>
              <p>{message.insight}</p>
            </details>
          )}
        </li>
      );
    }

    function TranslationBlock({ label, text }) {
      return (
        <div className="translation-block">
          <strong>{label}</strong>
          <div>{text}</div>
        </div>
      );
    }

    function Timeline({ currentPhase }) {
      const steps = [
        { id: 'introduce', label: 'Phase 1 · Introduce Positions', description: 'Moderator sets the scenario; philosophers respond in English.' },
        { id: 'cross-response', label: 'Phase 2 · Cross-Response', description: 'Agents critique each other; translations optional per turn.' },
        { id: 'synthesis', label: 'Phase 3 · Synthesis', description: 'Moderator prompts common ground; human prompts can interject.' },
      ];
      return (
        <div className="timeline">
          {steps.map(step => (
            <div key={step.id} className={`timeline-step ${currentPhase === step.id ? 'active' : ''}`}>
              <strong>{step.label}</strong>
              <p>{step.description}</p>
            </div>
          ))}
        </div>
      );
    }

    function PromptComposer({ onSubmit, roster }) {
      const [prompt, setPrompt] = React.useState('');
      const [audience, setAudience] = React.useState('all');

      const handleSubmit = () => {
        if (!prompt.trim()) return;
        onSubmit({ prompt, audience });
        setPrompt('');
      };

      return (
        <div className="prompt-composer">
          <label><strong>User Prompt Composer</strong></label>
          <textarea
            value={prompt}
            onChange={event => setPrompt(event.target.value)}
            placeholder="Pose a follow-up question, inject a scenario, or request synthesis…"
          />
          <div className="actions">
            <div className="toggle-bar">
              <button
                className={`pill ${audience === 'all' ? 'active' : ''}`}
                onClick={() => setAudience('all')}
              >
                Address entire council
              </button>
              {roster.map(philosopher => (
                <button
                  key={philosopher.id}
                  className={`pill ${audience === philosopher.id ? 'active' : ''}`}
                  onClick={() => setAudience(philosopher.id)}
                >
                  Direct to {philosopher.name}
                </button>
              ))}
            </div>
            <button className="primary-button" onClick={handleSubmit}>Send Prompt</button>
          </div>
        </div>
      );
    }

    function InspectorColumn({
      contextSnapshots,
      activeSnapshotId,
      onSelectSnapshot,
      messages,
      languageDefaults,
      onLanguageDefaultsChange,
      showInsights,
      onToggleInsights,
      eventFeed,
    }) {
      return (
        <div className="inspector-column">
          <PromptInspector
            snapshots={contextSnapshots}
            activeSnapshotId={activeSnapshotId}
            onSelectSnapshot={onSelectSnapshot}
            messages={messages}
          />
          <SessionControlDrawer
            languageDefaults={languageDefaults}
            onLanguageDefaultsChange={onLanguageDefaultsChange}
            showInsights={showInsights}
            onToggleInsights={onToggleInsights}
            eventFeed={eventFeed}
          />
        </div>
      );
    }

    function PromptInspector({ snapshots, activeSnapshotId, onSelectSnapshot, messages }) {
      if (!snapshots.length) {
        return (
          <aside className="panel">
            <header>
              <h3>Prompt Inspector</h3>
              <span className="badge">Transparency Log</span>
            </header>
            <p>No context snapshots yet. They will appear once the moderator prepares the first prompt.</p>
          </aside>
        );
      }

      const orderedSnapshots = [...snapshots].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const activeSnapshot = orderedSnapshots.find(snapshot => snapshot.id === activeSnapshotId) || orderedSnapshots[orderedSnapshots.length - 1];
      const messageMap = new Map(messages.map(message => [message.id, message]));
      const missing = activeSnapshot.contextMessages.filter(entry => !messageMap.has(entry.id));
      const recordedAt = new Date(activeSnapshot.timestamp).toLocaleString();

      const downloadText = (text, filename) => {
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      return (
        <aside className="panel">
          <header>
            <h3>Prompt Inspector</h3>
            <span className="badge">Transparency Log</span>
          </header>

          <div className="snapshot-selector">
            {orderedSnapshots.map(snapshot => (
              <button
                key={snapshot.id}
                className={`pill ${snapshot.id === activeSnapshot.id ? 'active' : ''}`}
                onClick={() => onSelectSnapshot(snapshot.id)}
              >
                Round {snapshot.round} · {snapshot.phase}
              </button>
            ))}
          </div>

          <div className="prompt-meta">
            <div><strong>Context ID</strong> {activeSnapshot.contextId}</div>
            <div><strong>Audience</strong> {activeSnapshot.audience}</div>
            <div><strong>Phase</strong> Round {activeSnapshot.round} · {activeSnapshot.phase}</div>
            <div><strong>Recorded</strong> {recordedAt}</div>
            <div><strong>User Prompt</strong> {activeSnapshot.userPrompt}</div>
          </div>

          <div className="toggle-bar">
            <span className={`pill ${missing.length === 0 ? 'highlight' : ''}`}>
              {missing.length === 0 ? 'Context mirror in sync' : `Pending ${missing.length} message${missing.length === 1 ? '' : 's'} from stream`}
            </span>
          </div>

          <div className="inspector-actions">
            <button className="ghost-button" onClick={() => downloadText(activeSnapshot.prompt.rendered, `${activeSnapshot.id}_prompt.txt`)}>Download prompt</button>
            <button className="ghost-button secondary" onClick={() => downloadText(activeSnapshot.prompt.templateSkeleton, `${activeSnapshot.id}_template.txt`)}>Download template</button>
          </div>

          <div>
            <strong>Instantiated Prompt</strong>
            <pre className="code-block">{activeSnapshot.prompt.rendered}</pre>
          </div>

          <details className="insight">
            <summary>Show template skeleton</summary>
            <pre className="code-block">{activeSnapshot.prompt.templateSkeleton}</pre>
          </details>

          {activeSnapshot.callPayload && (
            <div>
              <strong>Invocation Payload</strong>
              <pre className="code-block">{JSON.stringify(activeSnapshot.callPayload, null, 2)}</pre>
            </div>
          )}

          <AgentLens snapshot={activeSnapshot} messages={messages} />
        </aside>
      );
    }

    function AgentLens({ snapshot, messages }) {
      const messageMap = new Map(messages.map(message => [message.id, message]));
      const pending = snapshot.contextMessages.filter(entry => !messageMap.has(entry.id));

      return (
        <section>
          <strong>Agent Lens</strong>
          <div className="toggle-bar" style={{ margin: '6px 0' }}>
            <span className={`pill ${pending.length === 0 ? 'highlight' : ''}`}>
              {pending.length === 0 ? 'Mirror matches stream' : `Waiting on ${pending.length} transcript update${pending.length === 1 ? '' : 's'}`}
            </span>
          </div>
          <ul className="agent-context-list">
            {snapshot.contextMessages.length === 0 && (
              <li>
                <div>No prior statements; the agent only receives the user prompt.</div>
              </li>
            )}
            {snapshot.contextMessages.map(entry => (
              <li key={entry.id}>
                <div className="meta">{entry.speaker} · {entry.phase} · {formatTime(entry.timestamp)}</div>
                <div>{entry.surface}</div>
              </li>
            ))}
          </ul>
        </section>
      );
    }

    function SessionControlDrawer({ languageDefaults, onLanguageDefaultsChange, showInsights, onToggleInsights, eventFeed }) {
      const toggleDefault = (key) => {
        onLanguageDefaultsChange(prev => ({ ...prev, [key]: !prev[key] }));
      };

      return (
        <aside className="panel">
          <header>
            <h3>Session Controls</h3>
            <span className="badge">Participant Tools</span>
          </header>

          <div className="card">
            <strong>Language Defaults</strong>
            <div className="toggle-bar">
              <button className={`pill ${languageDefaults.english ? 'active' : ''}`} onClick={() => toggleDefault('english')}>
                EN auto
              </button>
              <button className={`pill ${languageDefaults.modern ? 'active' : ''}`} onClick={() => toggleDefault('modern')}>
                Modern auto
              </button>
              <button className={`pill ${languageDefaults.classical ? 'active' : ''}`} onClick={() => toggleDefault('classical')}>
                Classical auto
              </button>
            </div>
            <p>English stays locked; other layers load per new turn if enabled.</p>
          </div>

          <div className="card">
            <strong>Insights Visibility</strong>
            <div className="toggle-bar">
              <button className={`pill ${showInsights ? 'active' : ''}`} onClick={() => onToggleInsights(true)}>Show reasoning</button>
              <button className={`pill ${!showInsights ? 'active' : ''}`} onClick={() => onToggleInsights(false)}>Hide reasoning</button>
            </div>
            <p>Per-philosopher overrides remain in the roster.</p>
          </div>

          <div className="card">
            <strong>Event Feed</strong>
            <div className="event-feed">
              {eventFeed.length === 0 && <span>Stream initializing…</span>}
              {eventFeed.map((entry, idx) => (
                <span key={idx}>{entry}</span>
              ))}
            </div>
          </div>
        </aside>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
